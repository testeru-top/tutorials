---
tags: note
status: todo
priority: 1
time: 2022-06-06 16:02
things:  "[🧊](things:///show?id=JtkDsmtmq6Bd8ZbzKBJTW4)"
---
# 读取Excel文件

测试人员很喜欢用Excel来管理测试用例，在做自动化时，想要通过测试框架JUnit5进行对应的测试用例解析。在网上找了一下，常用的解析excel方式有三种：


|解析方式|说明|
|---|---|
|JXL|开源的Java Excel API项目<br/>2011后未更新|
|JExcel|不是JXL<br/>2019后未更新|
|Apache POI|[官网](https://poi.apache.org/)<br/>支持 xls、xlsx<br/>社区强大，更新快，至今还在更新|


综上比较，我个人推荐大家用POI进行解析，下面我们来看下具体解析过程。

## 解析步骤
#### pom导入相关依赖

```xml
<!-- https://mvnrepository.com/artifact/org.apache.poi/poi -->
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
    <version>${poi.version}</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml -->
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>${poi.version}</version>
</dependency>
```
- 完整依赖
```xml
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <java.version>11</java.version>
    <!-- 使用 Java 11 语言特性 ( -source 11 ) 并且还希望编译后的类与 JVM 11 ( -target 11 )兼容，您可以添加以下两个属性，它们是默认属性插件参数的名称-->
    <maven.compiler.target>11</maven.compiler.target>
    <maven.compiler.source>11</maven.compiler.source>
    <!-- 对应junit Jupiter的版本号;放在这里就不需要在每个依赖里面写版本号，导致对应版本号会冲突-->
    <junit.jupiter.version>5.8.2</junit.jupiter.version>

    <maven.compiler.version>3.8.1</maven.compiler.version>
    <maven.surefire.version>3.0.0-M5</maven.surefire.version>
    <!-- plugins -->
    <maven-surefire-plugin.version>3.0.0-M5</maven-surefire-plugin.version>
    <poi.version>5.2.2</poi.version>
</properties>

<!--    物料清单 (BOM)-->
<dependencyManagement>
    <dependencies>
        <!--当使用 Gradle 或 Maven 引用多个 JUnit 工件时，此物料清单 POM 可用于简化依赖项管理。不再需要在添加依赖时设置版本-->
        <dependency>
            <groupId>org.junit</groupId>
            <artifactId>junit-bom</artifactId>
            <version>${junit.jupiter.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>

    </dependencies>
</dependencyManagement>



<dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <!--            对应添加的依赖的作用范围-->
        <scope>test</scope>
    </dependency>

    <dependency>
        <groupId>org.junit.platform</groupId>
        <artifactId>junit-platform-suite</artifactId>
        <scope>test</scope>
    </dependency>

    <dependency>
        <groupId>org.junit.vintage</groupId>
        <artifactId>junit-vintage-engine</artifactId>
        <version>${junit.jupiter.version}</version>
    </dependency>


    <!-- https://mvnrepository.com/artifact/org.apache.poi/poi -->
    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi</artifactId>
        <version>${poi.version}</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml -->
    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi-ooxml</artifactId>
        <version>${poi.version}</version>
    </dependency>

</dependencies>


<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>${maven-surefire-plugin.version}</version>

            <dependencies>
                <dependency>
                    <groupId>org.junit.jupiter</groupId>
                    <artifactId>junit-jupiter-engine</artifactId>
                    <version>${junit.jupiter.version}</version>
                </dependency>
                <dependency>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                    <version>${junit.jupiter.version}</version>
                </dependency>
            </dependencies>
        </plugin>
    </plugins>
</build>
```


### poi解析步骤
 * 1、获取文件结尾类型「`xls`、`xlsx`」
 * 2、`excel` 文件加载为文件输入流
 * 3、获取工作薄对象`Workbook`
   * 如果是`xls`结尾用`HSSF` 
   * 如果是`xlsx`结尾用`XSSF`
 * 4、读取第一个`sheet`
 * 5、每一行具体数据为`list`
 * 6、从第一行开始解析
 * 7、最后关闭流


### demo分解
#### 获取工作薄对象Workbook
-  使用输入流的形式打开文件获取工作薄对象
```java
//方式一：流的形式打开文件
//使用 InputStream 比使用 File 需要更多内存，因此 File 可用
FileInputStream file = new FileInputStream(new File("src/test/resources/orderLines.xlsx"));
Workbook workbook = new XSSFWorkbook(file);
```
- 直接使用file打开文件获取工作薄对象
```java
//方式二：直接使用file
Workbook workbook = new XSSFWorkbook(new File("src/test/resources/orderLines.xlsx"));
```

#### 获取sheet
- 获取第一个sheet标签页
```java
//读取第一个sheet
Sheet sheet = workbook.getSheetAt(0);
```

- 想要获取哪个就读取哪个sheet
```java
//读取第n个sheet
Sheet sheet = workbook.getSheetAt(n-1);
```

-  获取当前工作薄有几个sheet标签页
```java
int numberOfSheets = workbook.getNumberOfSheets();
```
#### 获取行数
-  获取sheet中有多少行
 
```java
int rows = sheet.getPhysicalNumberOfRows();
```
-  一个sheet里面有多个row
```java
Map<Integer, List<Object>> data = new HashMap<>();
int i = 0;
for (Row row : sheet) {
   //{0=[]}
   data.put(i, new ArrayList<Object>());
   i++;
}
System.out.println("data：" + data);//data：{0=[], 1=[], 2=[]}
```

#### 获取每一个单元格数据
-  一行「row」有多个单元格「Cell」
```java
//map<行号,list是行内容>
Map<Integer, List<Object>> data = new HashMap<>();
int i = 0;
for (Row row : sheet) {
   //{0=[]}
   data.put(i, new ArrayList<Object>());

   for(Cell cell:row){
       //[]
       //每一个单元格就是ArrayList里面一个元素
       List<Object> objectList = data.get(i);

       objectList.add(cell);

   }
   i++;
}
System.out.println("data：" + data);
//data：{0=[item, quantity, unitPrice, orderDate], 1=[No. 9 Sprockets, 12.0, 1.23, 17-4月-2019], 2=[Widget (10mm), 4.0, 3.45, 16-1月-2022]}

```

#### 数据解析类型
- excel可以设置列的数据类型
```java
switch (cell.getCellType()) {
  //单元格类型枚举值为STRING时，将使用Cell接口的getRichStringCellValue()方法读取内容：
  //文本格式的内容读取
  case STRING:
      cell.getRichStringCellValue().getString();
      break;
  // 数字、日期
  case NUMERIC:
      if (DateUtil.isCellDateFormatted(cell)) {
          //日期型以年-月-日格式存储
          SimpleDateFormat fmt = new SimpleDateFormat("yyyy-MM-dd");
          fmt.format(cell.getDateCellValue());
      } else {
          cell.getNumericCellValue();
      }
      break;
  case BOOLEAN:
      cell.getBooleanCellValue();
      break;
  case FORMULA:
      cell.getCellFormula();
      break;
  default: data.get(Integer.valueOf(i)).add(" ");
}
```


### 完整demo
```java
import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ExcelTest {
    @Test
    void test() throws IOException, InvalidFormatException {

        //方式一：流的形式打开文件
        //使用 InputStream 比使用 File 需要更多内存，因此 File 可用
//        FileInputStream file = new FileInputStream(new File("src/test/resources/orderLines.xlsx"));
//        Workbook workbook = new XSSFWorkbook(file);
        //方式二：直接使用file
        Workbook workbook = new XSSFWorkbook(new File("src/test/resources/orderLines.xlsx"));
        //读取第一个sheet
        Sheet sheet = workbook.getSheetAt(0);
        //map<行号,list是行内容>
        Map<Integer, List<Object>> data = new HashMap<>();
        int i = 0;
        for (Row row : sheet) {
            //{0=[]}
            data.put(i, new ArrayList<Object>());
            System.out.println("data："+ data);
            for (Cell cell : row) {
                List<Object> objects = data.get(Integer.valueOf(i));
                switch (cell.getCellType()) {
                    //单元格类型枚举值为STRING时，将使用Cell接口的getRichStringCellValue()方法读取内容：
                    //文本格式的内容读取
                    case STRING:
                        objects.add(cell.getRichStringCellValue().getString());
                        break;
                    // 数字、日期
                    case NUMERIC:
                        if (DateUtil.isCellDateFormatted(cell)) {
                            //日期型以年-月-日格式存储
                            SimpleDateFormat fmt = new SimpleDateFormat("yyyy-MM-dd");
                            objects.add(fmt.format(cell.getDateCellValue()) + "");
                        } else {
                            objects.add(cell.getNumericCellValue() + "");
                        }
                        break;
                    case BOOLEAN:
                        objects.add(cell.getBooleanCellValue() + "");
                        break;
                    case FORMULA:
                        objects.add(cell.getCellFormula() + "");
                        break;
                    default: data.get(Integer.valueOf(i)).add(" ");
                }
            }
            i++;
        }
        System.out.println(data);
        //关闭流
        workbook.close();
    }
}
```


##  结论

本文说明了如何使用Apache POI API  从 Java 程序中读取Excel 文件

本文的完整源代码可以在[GitHub 项目](https://github.com/testeru-top/java_code/blob/master/juit5_tutorials/junit5_excel/src/test/java/top/tester/excel/ExcelTest.java)中找到。